use std::f64::consts::PI;

use num::{Float, ToPrimitive, Unsigned};

/// Computes the $k^{th}$ zero of the $J_0(x)$ Bessel function.
///
/// # Notes
///
/// Note that the first 20 zeros are tabulated.  After that, they are computed
pub fn bessel_j0_zeros<F: Float, U: Unsigned + ToPrimitive>(k: U) -> f64 {
    const J_Z: [f64; 20] = [
        2.404_825_557_695_773,
        5.520_078_110_286_311,
        8.653_727_912_911_013,
        1.179_153_443_901_428_1E1,
        1.493_091_770_848_778_7E1,
        1.807_106_396_791_092_4E1,
        2.121_163_662_987_926E1,
        2.435_247_153_074_930_2E1,
        2.749_347_913_204_025_3E1,
        3.063_460_646_843_197_6E1,
        3.377_582_021_357_357E1,
        3.691_709_835_366_404_5E1,
        4.005_842_576_462_824E1,
        4.319_979_171_317_673E1,
        4.634_118_837_166_181_5E1,
        4.948_260_989_739_781_5E1,
        5.262_405_184_111_5E1,
        5.576_551_075_501_998E1,
        5.890_698_392_608_094E1,
        6.204_846_919_022_716_6E1,
    ];

    let r: f64;
    let r2: f64;
    let mut z: f64;

    if J_Z.len() < k.to_usize().unwrap() {
        z = PI * (k.to_f64().unwrap() - 0.25E+00);
        r = 1.0E+00 / z;
        r2 = r * r;
        z = mcmahon_expansion(z, r, r2);
    } else {
        z = J_Z[k.to_usize().unwrap() - 1];
    }

    z
}

/// TODO: Document
fn mcmahon_expansion(z: f64, r: f64, r2: f64) -> f64 {
    z + r
        * (0.125E+00
            + r2 * (-8.072_916_666_666_667E-2
                + r2 * (2.460_286_458_333_333_4E-1
                    + r2 * (-1.824_438_767_206_101
                        + r2 * (2.533_641_479_734_390_6E1
                            + r2 * (-5.676_444_121_351_834E2
                                + r2 * (1.869_047_652_823_206_6E4
                                    + r2 * (-8.493_535_802_991_488E5
                                        + r2 * 5.092_254_624_022_268E7))))))))
}

/// TODO: Document
fn hankel_expansion(x: f64, x2: f64) -> f64 {
    x * (2.026_423_672_846_755_5E-1
        + x2 * x2
            * (-3.033_804_297_112_902_7E-4
                + x2 * (1.989_243_642_459_693E-4
                    + x2 * (-2.289_699_027_721_116_6E-4
                        + x2 * (4.337_107_191_307_463E-4
                            + x2 * (-1.236_323_497_271_754E-3
                                + x2 * (4.961_014_232_688_831_4E-3
                                    + x2 * (-2.668_373_937_023_237_7E-2
                                        + x2 * 1.853_953_982_063_456_2E-1))))))))
}

/// Computes the kth zero of the $J_0(x)$ Bessel function.
///
/// # Notes
///
pub fn bessel_j1_squared<F: Float, U: Unsigned + ToPrimitive>(k: U) -> f64 {
    /// Note that the first 20 zeros are tabulated.  After that, they are computed
    const J_1: &[f64; 21] = &[
        2.695_141_239_419_169E-1,
        1.157_801_385_822_036_9E-1,
        7.368_635_113_640_822E-2,
        5.403_757_319_811_628E-2,
        4.266_142_901_724_309E-2,
        3.524_210_349_099_61E-2,
        3.002_107_010_305_467_3E-2,
        2.614_739_149_530_809E-2,
        2.315_912_182_469_139_3E-2,
        2.078_382_912_226_786E-2,
        1.885_045_066_931_767E-2,
        1.724_615_756_966_500_8E-2,
        1.589_351_810_592_36E-2,
        1.473_762_609_647_219E-2,
        1.373_846_514_538_711_7E-2,
        1.286_618_173_761_513_3E-2,
        1.209_805_154_862_679_7E-2,
        1.141_647_122_449_160_9E-2,
        1.080_759_279_118_020_4E-2,
        1.026_037_292_628_076_2E-2,
        9.765_897_139_791_051E-3,
    ];

    let x: f64;
    let x2: f64;
    let z: f64;

    if J_1.len() < k.to_usize().unwrap() {
        x = 1.0 / (k.to_f64().unwrap() - 0.25);
        x2 = x * x;

        z = hankel_expansion(x, x2);
    } else {
        z = J_1[k.to_usize().unwrap() - 1];
    }
    z
}
