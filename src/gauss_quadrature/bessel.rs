extern crate test;
use std::f64::consts::PI;

use num::{ToPrimitive, Unsigned};

/// Computes the $k^{th}$ zero of the $J_0(x)$ Bessel function.
///
/// # Notes
///
/// Note that the first 20 zeros are tabulated.  After that, they are computed using McMahon expansion
pub fn bessel_j0_zeros<U: Unsigned + ToPrimitive>(k: U) -> f64 {
    const J_Z: [f64; 20] = [
        2.404_825_557_695_773,
        5.520_078_110_286_311,
        8.653_727_912_911_013,
        1.179_153_443_901_428_1E1,
        1.493_091_770_848_778_7E1,
        1.807_106_396_791_092_4E1,
        2.121_163_662_987_926E1,
        2.435_247_153_074_930_2E1,
        2.749_347_913_204_025_3E1,
        3.063_460_646_843_197_6E1,
        3.377_582_021_357_357E1,
        3.691_709_835_366_404_5E1,
        4.005_842_576_462_824E1,
        4.319_979_171_317_673E1,
        4.634_118_837_166_181_5E1,
        4.948_260_989_739_781_5E1,
        5.262_405_184_111_5E1,
        5.576_551_075_501_998E1,
        5.890_698_392_608_094E1,
        6.204_846_919_022_716_6E1,
    ];

    let r: f64;
    let r2: f64;
    let mut z: f64;

    if J_Z.len() < k.to_usize().unwrap() {
        z = PI * (k.to_f64().unwrap() - 0.25E+00);
        r = 1.0E+00 / z;
        r2 = r * r;
        z = mcmahon_expansion(z, r, r2);
    } else {
        z = J_Z[k.to_usize().unwrap() - 1];
    }

    z
}

/// This functions is used to approximate the $k^{th}$ zero of the $J_0(x)$ Bessel function,
/// for the case where $k$ is greater than 20.
///
/// Intended for internal use of this crate only, in this specific implementation of Gauss-Legendre's rule.
fn mcmahon_expansion(z: f64, r: f64, r2: f64) -> f64 {
    z + r
        * (0.125E+00
            + r2 * (-8.072_916_666_666_667E-2
                + r2 * (2.460_286_458_333_333_4E-1
                    + r2 * (-1.824_438_767_206_101
                        + r2 * (2.533_641_479_734_390_6E1
                            + r2 * (-5.676_444_121_351_834E2
                                + r2 * (1.869_047_652_823_206_6E4
                                    + r2 * (-8.493_535_802_991_488E5
                                        + r2 * 5.092_254_624_022_268E7))))))))
}

/// This function is used to approximate $J_1$ Bessel function,
/// applied the $k$ zero of the $J_0(x)$ Bessel function, in the case where $k$ is greater than 21.
///
/// Intended for internal use of this crate only, in this specific implementation of Gauss-Legendre's rule.
fn hankel_expansion(x: f64, x2: f64) -> f64 {
    x * (2.026_423_672_846_755_5E-1
        + x2 * x2
            * (-3.033_804_297_112_902_7E-4
                + x2 * (1.989_243_642_459_693E-4
                    + x2 * (-2.289_699_027_721_116_6E-4
                        + x2 * (4.337_107_191_307_463E-4
                            + x2 * (-1.236_323_497_271_754E-3
                                + x2 * (4.961_014_232_688_831_4E-3
                                    + x2 * (-2.668_373_937_023_237_7E-2
                                        + x2 * 1.853_953_982_063_456_2E-1))))))))
}

/// Apply $J_1$ Bessel function to the $k$ zeros of the $J_0(x)$ Bessel function.       
/// Then computes their squared value.
///
/// # Notes
///
/// Note that the first 21 first values are tabulated.  After that, they are computed using Hankel expansion.
pub fn bessel_j1_squared<U: Unsigned + ToPrimitive>(k: U) -> f64 {
    const J_1: &[f64; 21] = &[
        2.695_141_239_419_169E-1,
        1.157_801_385_822_036_9E-1,
        7.368_635_113_640_822E-2,
        5.403_757_319_811_628E-2,
        4.266_142_901_724_309E-2,
        3.524_210_349_099_61E-2,
        3.002_107_010_305_467_3E-2,
        2.614_739_149_530_809E-2,
        2.315_912_182_469_139_3E-2,
        2.078_382_912_226_786E-2,
        1.885_045_066_931_767E-2,
        1.724_615_756_966_500_8E-2,
        1.589_351_810_592_36E-2,
        1.473_762_609_647_219E-2,
        1.373_846_514_538_711_7E-2,
        1.286_618_173_761_513_3E-2,
        1.209_805_154_862_679_7E-2,
        1.141_647_122_449_160_9E-2,
        1.080_759_279_118_020_4E-2,
        1.026_037_292_628_076_2E-2,
        9.765_897_139_791_051E-3,
    ];

    let x: f64;
    let x2: f64;
    let z: f64;

    if J_1.len() < k.to_usize().unwrap() {
        x = 1.0 / (k.to_f64().unwrap() - 0.25);
        x2 = x * x;

        z = hankel_expansion(x, x2);
    } else {
        z = J_1[k.to_usize().unwrap() - 1];
    }
    z
}

#[cfg(test)]
mod tests {

    use num_traits::Pow;

    use super::*;

    const EPSILON: f64 = 10e-5;

    // Computed using scipy special function jn_zeros
    // https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jn_zeros.html
    const BESSEL_J0_FIRST_100_ZEROS: [f64; 100] = [
        2.40482556,
        5.52007811,
        8.65372791,
        11.79153444,
        14.93091771,
        18.07106397,
        21.21163663,
        24.35247153,
        27.49347913,
        30.63460647,
        33.77582021,
        36.91709835,
        40.05842576,
        43.19979171,
        46.34118837,
        49.4826099,
        52.62405184,
        55.76551076,
        58.90698393,
        62.04846919,
        65.1899648,
        68.33146933,
        71.4729816,
        74.61450064,
        77.75602563,
        80.89755587,
        84.03909078,
        87.18062984,
        90.32217264,
        93.46371878,
        96.60526795,
        99.74681986,
        102.88837425,
        106.02993092,
        109.17148965,
        112.31305028,
        115.45461265,
        118.59617663,
        121.73774209,
        124.87930891,
        128.02087701,
        131.16244628,
        134.30401664,
        137.44558802,
        140.58716035,
        143.72873357,
        146.87030763,
        150.01188246,
        153.15345802,
        156.29503427,
        159.43661116,
        162.57818867,
        165.71976675,
        168.86134537,
        172.0029245,
        175.14450412,
        178.2860842,
        181.42766471,
        184.56924564,
        187.71082696,
        190.85240865,
        193.9939907,
        197.13557309,
        200.27715579,
        203.41873881,
        206.56032212,
        209.7019057,
        212.84348956,
        215.98507367,
        219.12665803,
        222.26824262,
        225.40982743,
        228.55141247,
        231.6929977,
        234.83458314,
        237.97616877,
        241.11775458,
        244.25934056,
        247.40092672,
        250.54251304,
        253.68409951,
        256.82568614,
        259.96727291,
        263.10885982,
        266.25044687,
        269.39203405,
        272.53362135,
        275.67520878,
        278.81679633,
        281.95838398,
        285.09997175,
        288.24155963,
        291.38314761,
        294.52473568,
        297.66632386,
        300.80791213,
        303.94950049,
        307.09108893,
        310.23267746,
        313.37426608,
    ];

    // Compute Bessel J1 of first 100 roots of Bessel J0
    // Computed using scipy special function j1
    const BESSEL_J1_FIRST_100: [f64; 100] = [
        0.5191474972894669,
        -0.34026480655836816,
        0.27145229992838193,
        -0.23245983136472478,
        0.20654643307799597,
        -0.18772880304043946,
        0.17326589422922986,
        -0.16170155068925002,
        0.15218121377059457,
        -0.14416597768637324,
        0.13729694340850299,
        -0.13132462666866793,
        0.12606949712727336,
        -0.12139862477175016,
        0.11721119889066538,
        -0.1134291926164298,
        0.10999114304627802,
        -0.10684788825471286,
        0.10395957286936207,
        -0.10129349893394328,
        0.09882255380119992,
        -0.09652404046467991,
        0.09437879398467641,
        -0.09237050482355331,
        0.09048519416295768,
        -0.0887108024409698,
        0.0870368633240976,
        -0.08545424291091484,
        0.08395492928345757,
        -0.0825318613083098,
        0.08117878831953207,
        -0.07989015430874276,
        0.07866100171930493,
        -0.07748689103965987,
        0.07636383321829138,
        -0.07528823255205501,
        0.0742568381822715,
        -0.07326670270620797,
        0.07231514670236977,
        -0.071399728196232,
        0.0705182162733357,
        -0.06966856819003345,
        0.06884890944684943,
        -0.068057516381685,
        0.06729280091473991,
        -0.06655329713771117,
        0.06583764948942708,
        -0.065144602300793,
        0.06447299052550669,
        -0.06382173150081485,
        0.063189817605714,
        -0.06257630970331138,
        0.06198033127024816,
        -0.06140106312970013,
        0.06083773871596136,
        -0.060289639808346895,
        0.059756092680416394,
        -0.059236464617564454,
        0.0587301607620443,
        -0.058236621249651344,
        0.057755318606728306,
        -0.05728575537997613,
        0.05682746197485656,
        -0.05637999468123287,
        0.05594293386737833,
        -0.05551588232564262,
        0.05509846375495184,
        -0.05469032136696416,
        0.0542911166041467,
        -0.05390052795930568,
        0.05351824988721487,
        -0.0531439917999698,
        0.05277747713856061,
        -0.05241844251392233,
        0.052066636911401065,
        -0.05172182095317582,
        0.051383766213711116,
        -0.05105225458379304,
        0.05072707767912493,
        -0.050408036289839954,
        0.05009493986762599,
        -0.0497876060474634,
        0.04948586020124814,
        -0.04918953502081814,
        0.048898470128121006,
        -0.0486125117104598,
        0.04833151217893186,
        -0.04805532984833819,
        0.04778382863698613,
        -0.047516877784940494,
        0.04725435158939828,
        -0.046996129155970165,
        0.04674209416475137,
        -0.04649213465015328,
        0.046246142793549716,
        -0.04600401472786514,
        0.04576565035330103,
        -0.04553095316345705,
        0.04529983008116179,
        -0.04507219130337834,
    ];

    #[test]
    fn test_bessel_j0() {
        for k in 1..100_usize {
            // computing root using method cited in Ignace Bogaert paper
            let x: f64 = bessel_j0_zeros::<usize>(k);

            // reference value
            let j0x: f64 = BESSEL_J0_FIRST_100_ZEROS[k - 1];

            if k < 10 {
                println!(
                    "bessel_j0_zero: {} \t scipy: {} \t difference: {}",
                    x,
                    j0x,
                    (x - j0x).abs()
                );
            }

            assert!(x - j0x < EPSILON);
        }
    }

    #[test]
    fn test_bessel_j1_squared() {
        for k in 1..100_usize {
            // computing bessel J0 root using method cited in Ignace Bogaert paper
            let x: f64 = bessel_j1_squared(k);

            // reference value
            let j1 = BESSEL_J1_FIRST_100[k - 1];
            let j1_squared: f64 = j1.pow(2);

            if k < 10 {
                println!(
                    "bessel_j1_squared: {} \t scipy: {} \t difference: {}",
                    x,
                    j1_squared,
                    (x - j1_squared).abs()
                );
            }

            assert!(x - j1_squared < EPSILON);
        }
    }
}
